<html lang="en">
<head>
<title>Verify - The `GnuPG Made Easy' Reference Manual</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="The `GnuPG Made Easy' Reference Manual">
<meta name="generator" content="makeinfo 4.11">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Crypto-Operations.html#Crypto-Operations" title="Crypto Operations">
<link rel="prev" href="Decrypt.html#Decrypt" title="Decrypt">
<link rel="next" href="Decrypt-and-Verify.html#Decrypt-and-Verify" title="Decrypt and Verify">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<p>
<a name="Verify"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="Decrypt-and-Verify.html#Decrypt-and-Verify">Decrypt and Verify</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Decrypt.html#Decrypt">Decrypt</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Crypto-Operations.html#Crypto-Operations">Crypto Operations</a>
<hr>
</div>

<h4 class="subsection">7.6.2 Verify</h4>

<p><a name="index-verification-261"></a><a name="index-signature_002c-verification-262"></a><a name="index-cryptographic-operation_002c-verification-263"></a><a name="index-cryptographic-operation_002c-signature-check-264"></a><a name="index-signature-notation-data-265"></a><a name="index-notation-data-266"></a>

<div class="defun">
&mdash; Function: gpgme_error_t <b>gpgme_op_verify</b> (<var>gpgme_ctx_t&nbsp;ctx<!-- /@w -->, gpgme_data_t&nbsp;sig<!-- /@w -->, gpgme_data_t&nbsp;signed_text<!-- /@w -->, gpgme_data_t&nbsp;plain<!-- /@w --></var>)<var><a name="index-gpgme_005fop_005fverify-267"></a></var><br>
<blockquote><p>The function <code>gpgme_op_verify</code> verifies that the signature in the
data object <var>sig</var> is a valid signature.  If <var>sig</var> is a
detached signature, then the signed text should be provided in
<var>signed_text</var> and <var>plain</var> should be a null pointer. 
Otherwise, if <var>sig</var> is a normal (or cleartext) signature,
<var>signed_text</var> should be a null pointer and <var>plain</var> should be a
writable data object that will contain the plaintext after successful
verification.

        <p>The results of the individual signature verifications can be retrieved
with <code>gpgme_op_verify_result</code>.

        <p>The function returns the error code <code>GPG_ERR_NO_ERROR</code> if the
operation could be completed successfully, <code>GPG_ERR_INV_VALUE</code> if
<var>ctx</var>, <var>sig</var> or <var>plain</var> is not a valid pointer,
<code>GPG_ERR_NO_DATA</code> if <var>sig</var> does not contain any data to
verify, and passes through any errors that are reported by the crypto
engine support routines. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: gpgme_error_t <b>gpgme_op_verify_start</b> (<var>gpgme_ctx_t&nbsp;ctx<!-- /@w -->, gpgme_data_t&nbsp;sig<!-- /@w -->, gpgme_data_t&nbsp;signed_text<!-- /@w -->, gpgme_data_t&nbsp;plain<!-- /@w --></var>)<var><a name="index-gpgme_005fop_005fverify_005fstart-268"></a></var><br>
<blockquote><p>The function <code>gpgme_op_verify_start</code> initiates a
<code>gpgme_op_verify</code> operation.  It can be completed by calling
<code>gpgme_wait</code> on the context.  See <a href="Waiting-For-Completion.html#Waiting-For-Completion">Waiting For Completion</a>.

        <p>The function returns the error code <code>GPG_ERR_NO_ERROR</code> if the
operation could be started successfully, <code>GPG_ERR_INV_VALUE</code> if
<var>ctx</var>, <var>sig</var> or <var>plain</var> is not a valid pointer, and
<code>GPG_ERR_NO_DATA</code> if <var>sig</var> or <var>plain</var> does not contain
any data to verify. 
</p></blockquote></div>

<div class="defun">
&mdash; Data type: <b>gpgme_sig_notation_t</b><var><a name="index-gpgme_005fsig_005fnotation_005ft-269"></a></var><br>
<blockquote><p>This is a pointer to a structure used to store a part of the result of
a <code>gpgme_op_verify</code> operation.  The structure contains the
following members:

          <dl>
<dt><code>gpgme_sig_notation_t next</code><dd>This is a pointer to the next new signature notation structure in the
linked list, or <code>NULL</code> if this is the last element.

          <br><dt><code>char *name</code><dd>The name of the notation field.  If this is <code>NULL</code>, then the
member <code>value</code> will contain a policy URL.

          <br><dt><code>int name_len</code><dd>The length of the <code>name</code> field.  For strings the length is
counted without the trailing binary zero.

          <br><dt><code>char *value</code><dd>The value of the notation field.  If <code>name</code> is <code>NULL</code>, then
this is a policy URL.

          <br><dt><code>int value_len</code><dd>The length of the <code>value</code> field.  For strings the length is
counted without the trailing binary zero.

          <br><dt><code>gpgme_sig_notation_flags_t flags</code><dd>The accumulated flags field.  This field contains the flags associated
with the notation data in an accumulated form which can be used as an
argument to the function <code>gpgme_sig_notation_add</code>.  The value
<code>flags</code> is a bitwise-or combination of one or multiple of the
following bit values:

               <dl>
<dt><code>GPGME_SIG_NOTATION_HUMAN_READABLE</code><dd>The <code>GPGME_SIG_NOTATION_HUMAN_READABLE</code> symbol specifies that the
notation data is in human readable form

               <br><dt><code>GPGME_SIG_NOTATION_CRITICAL</code><dd>The <code>GPGME_SIG_NOTATION_CRITICAL</code> symbol specifies that the
notation data is critical.

          </dl>

          <br><dt><code>unsigned int human_readable : 1</code><dd>This is true if the <code>GPGME_SIG_NOTATION_HUMAN_READABLE</code> flag is
set and false otherwise.  This flag is only valid for notation data,
not for policy URLs.

          <br><dt><code>unsigned int critical : 1</code><dd>This is true if the <code>GPGME_SIG_NOTATION_CRITICAL</code> flag is set and
false otherwise.  This flag is valid for notation data and policy URLs.

        </dl>
        </p></blockquote></div>

<div class="defun">
&mdash; Data type: <b>gpgme_signature_t</b><var><a name="index-gpgme_005fsignature_005ft-270"></a></var><br>
<blockquote><p>This is a pointer to a structure used to store a part of the result of
a <code>gpgme_op_verify</code> operation.  The structure contains the
following members:

          <dl>
<dt><code>gpgme_signature_t next</code><dd>This is a pointer to the next new signature structure in the linked
list, or <code>NULL</code> if this is the last element.

          <br><dt><code>gpgme_sigsum_t summary</code><dd>This is a bit vector giving a summary of the signature status.  It
provides an easy interface to a defined semantic of the signature
status.  Checking just one bit is sufficient to see whether a
signature is valid without any restrictions.

          <p>The defined bits are:
               <dl>
  <dt><code>GPGME_SIGSUM_VALID</code><dd>  The signature is fully valid.

               <br><dt><code>GPGME_SIGSUM_GREEN</code><dd>  The signature is good but one might want to display some extra
  information.  Check the other bits.

               <br><dt><code>GPGME_SIGSUM_RED</code><dd>  The signature is bad. It might be useful to check other bits and
  display more information, i.e. a revoked certificate might not render a
  signature invalid when the message was received prior to the cause for
  the revocation.

               <br><dt><code>GPGME_SIGSUM_KEY_REVOKED</code><dd>  The key or at least one certificate has been revoked.

               <br><dt><code>GPGME_SIGSUM_KEY_EXPIRED</code><dd>  The key or one of the certificates has expired. It is probably a good
  idea to display the date of the expiration.

               <br><dt><code>GPGME_SIGSUM_SIG_EXPIRED</code><dd>  The signature has expired.

               <br><dt><code>GPGME_SIGSUM_KEY_MISSING</code><dd>  Can't verify due to a missing key or certificate.

               <br><dt><code>GPGME_SIGSUM_CRL_MISSING</code><dd>  The CRL (or an equivalent mechanism) is not available.

               <br><dt><code>GPGME_SIGSUM_CRL_TOO_OLD</code><dd>  Available CRL is too old.

               <br><dt><code>GPGME_SIGSUM_BAD_POLICY</code><dd>  A policy requirement was not met.

               <br><dt><code>GPGME_SIGSUM_SYS_ERROR</code><dd>  A system error occured. 
  </dl>

          <br><dt><code>char *fpr</code><dd>This is the fingerprint or key ID of the signature.

          <br><dt><code>gpgme_error_t status</code><dd>This is the status of the signature.  In particular, the following
status codes are of interest:

               <dl>
  <dt><code>GPG_ERR_NO_ERROR</code><dd>  This status indicates that the signature is valid.  For the combined
  result this status means that all signatures are valid.

               <br><dt><code>GPG_ERR_SIG_EXPIRED</code><dd>  This status indicates that the signature is valid but expired.  For
  the combined result this status means that all signatures are valid
  and expired.

               <br><dt><code>GPG_ERR_KEY_EXPIRED</code><dd>  This status indicates that the signature is valid but the key used to
  verify the signature has expired.  For the combined result this status
  means that all signatures are valid and all keys are expired.

               <br><dt><code>GPG_ERR_CERT_REVOKED</code><dd>  This status indicates that the signature is valid but the key used
  to verify the signature has been revoked.  For the combined result
  this status means that all signatures are valid and all keys are
  revoked.

               <br><dt><code>GPG_ERR_BAD_SIGNATURE</code><dd>  This status indicates that the signature is invalid.  For the combined
  result this status means that all signatures are invalid.

               <br><dt><code>GPG_ERR_NO_PUBKEY</code><dd>  This status indicates that the signature could not be verified due to
  a missing key.  For the combined result this status means that all
  signatures could not be checked due to missing keys.

               <br><dt><code>GPG_ERR_GENERAL</code><dd>  This status indicates that there was some other error which prevented
  the signature verification. 
  </dl>

          <br><dt><code>gpgme_sig_notation_t notations</code><dd>This is a linked list with the notation data and policy URLs.

          <br><dt><code>unsigned long timestamp</code><dd>The creation timestamp of this signature.

          <br><dt><code>unsigned long exp_timestamp</code><dd>The expiration timestamp of this signature, or 0 if the signature does
not expire.

          <br><dt><code>unsigned int wrong_key_usage : 1</code><dd>This is true if the key was not used according to its policy.

          <br><dt><code>unsigned int pka_trust : 2</code><dd>This is set to the trust information gained by means of the PKA system. 
Values are:
               <dl>
  <dt><code>0</code><dd>        No PKA information available or verification not possible. 
  <br><dt><code>1</code><dd>        PKA verification failed. 
  <br><dt><code>2</code><dd>        PKA verification succeeded. 
  <br><dt><code>3</code><dd>        Reserved for future use. 
  </dl>
          Depending on the configuration of the engine, this metric may also be
reflected by the validity of the signature.

          <br><dt><code>unsigned int chain_model : 1</code><dd>This is true if the validity of the signature has been checked using the
chain model.  In the chain model the time the signature has been created
must be within the validity period of the certificate and the time the
certificate itself has been created must be within the validity period
of the issuing certificate.  In contrast the default validation model
checks the validity of signature as well at the entire certificate chain
at the current time.

          <br><dt><code>gpgme_validity_t validity</code><dd>The validity of the signature.

          <br><dt><code>gpgme_error_t validity_reason</code><dd>If a signature is not valid, this provides a reason why.

          <br><dt><code>gpgme_pubkey_algo_t</code><dd>The public key algorithm used to create this signature.

          <br><dt><code>gpgme_hash_algo_t</code><dd>The hash algorithm used to create this signature. 
</dl>
        </p></blockquote></div>

<div class="defun">
&mdash; Data type: <b>gpgme_verify_result_t</b><var><a name="index-gpgme_005fverify_005fresult_005ft-271"></a></var><br>
<blockquote><p>This is a pointer to a structure used to store the result of a
<code>gpgme_op_verify</code> operation.  After verifying a signature, you
can retrieve the pointer to the result with
<code>gpgme_op_verify_result</code>.  If the operation failed this might be
a <code>NULL</code> pointer.  The structure contains the following member:

          <dl>
<dt><code>gpgme_signature_t signatures</code><dd>A linked list with information about all signatures for which a
verification was attempted.

          <br><dt><code>char *file_name</code><dd>This is the filename of the original plaintext message file if it is
known, otherwise this is a null pointer. 
</dl>
        </p></blockquote></div>

<div class="defun">
&mdash; Function: gpgme_verify_result_t <b>gpgme_op_verify_result</b> (<var>gpgme_ctx_t&nbsp;ctx<!-- /@w --></var>)<var><a name="index-gpgme_005fop_005fverify_005fresult-272"></a></var><br>
<blockquote><p>The function <code>gpgme_op_verify_result</code> returns a
<code>gpgme_verify_result_t</code> pointer to a structure holding the result
of a <code>gpgme_op_verify</code> operation.  The pointer is only valid if
the last operation on the context was a <code>gpgme_op_verify</code>,
<code>gpgme_op_verify_start</code>, <code>gpgme_op_decrypt_verify</code> or
<code>gpgme_op_decrypt_verify_start</code> operation, and if this operation
finished successfully (for <code>gpgme_op_decrypt_verify</code> and
<code>gpgme_op_decrypt_verify_start</code>, the error code
<code>GPG_ERR_NO_DATA</code> counts as successful in this context).  The
returned pointer is only valid until the next operation is started on
the context. 
</p></blockquote></div>

   <p>The following interfaces are deprecated and only provided for backward
compatibility.  Don't use them.  They will be removed in a future
version of <acronym>GPGME</acronym>.

<div class="defun">
&mdash; Data type: <b>enum gpgme_sig_stat_t</b><var><a name="index-enum-gpgme_005fsig_005fstat_005ft-273"></a></var><br>
<blockquote><p><a name="index-gpgme_005fsig_005fstat_005ft-274"></a>The <code>gpgme_sig_stat_t</code> type holds the result of a signature check, or
the combined result of all signatures.  The following results are
possible:

          <dl>
<dt><code>GPGME_SIG_STAT_NONE</code><dd>This status should not occur in normal operation.

          <br><dt><code>GPGME_SIG_STAT_GOOD</code><dd>This status indicates that the signature is valid.  For the combined
result this status means that all signatures are valid.

          <br><dt><code>GPGME_SIG_STAT_GOOD_EXP</code><dd>This status indicates that the signature is valid but expired.  For
the combined result this status means that all signatures are valid
and expired.

          <br><dt><code>GPGME_SIG_STAT_GOOD_EXPKEY</code><dd>This status indicates that the signature is valid but the key used to
verify the signature has expired.  For the combined result this status
means that all signatures are valid and all keys are expired.

          <br><dt><code>GPGME_SIG_STAT_BAD</code><dd>This status indicates that the signature is invalid.  For the combined
result this status means that all signatures are invalid.

          <br><dt><code>GPGME_SIG_STAT_NOKEY</code><dd>This status indicates that the signature could not be verified due to
a missing key.  For the combined result this status means that all
signatures could not be checked due to missing keys.

          <br><dt><code>GPGME_SIG_STAT_NOSIG</code><dd>This status indicates that the signature data provided was not a real
signature.

          <br><dt><code>GPGME_SIG_STAT_ERROR</code><dd>This status indicates that there was some other error which prevented
the signature verification.

          <br><dt><code>GPGME_SIG_STAT_DIFF</code><dd>For the combined result this status means that at least two signatures
have a different status.  You can get each key's status with
<code>gpgme_get_sig_status</code>. 
</dl>
        </p></blockquote></div>

<div class="defun">
&mdash; Function: const char * <b>gpgme_get_sig_status</b> (<var>gpgme_ctx_t&nbsp;ctx<!-- /@w -->, int&nbsp;idx<!-- /@w -->, gpgme_sig_stat_t&nbsp;*r_stat<!-- /@w -->, time_t&nbsp;*r_created<!-- /@w --></var>)<var><a name="index-gpgme_005fget_005fsig_005fstatus-275"></a></var><br>
<blockquote><p>The function <code>gpgme_get_sig_status</code> is equivalent to:

     <pre class="example">            gpgme_verify_result_t result;
            gpgme_signature_t sig;
          
            result = gpgme_op_verify_result (ctx);
            sig = result-&gt;signatures;
          
            while (sig &amp;&amp; idx)
              {
                sig = sig-&gt;next;
                idx--;
              }
            if (!sig || idx)
              return NULL;
          
            if (r_stat)
              {
                switch (gpg_err_code (sig-&gt;status))
          	{
          	case GPG_ERR_NO_ERROR:
          	  *r_stat = GPGME_SIG_STAT_GOOD;
          	  break;
          
          	case GPG_ERR_BAD_SIGNATURE:
          	  *r_stat = GPGME_SIG_STAT_BAD;
          	  break;
          
          	case GPG_ERR_NO_PUBKEY:
          	  *r_stat = GPGME_SIG_STAT_NOKEY;
          	  break;
          
          	case GPG_ERR_NO_DATA:
          	  *r_stat = GPGME_SIG_STAT_NOSIG;
          	  break;
          
          	case GPG_ERR_SIG_EXPIRED:
          	  *r_stat = GPGME_SIG_STAT_GOOD_EXP;
          	  break;
          
          	case GPG_ERR_KEY_EXPIRED:
          	  *r_stat = GPGME_SIG_STAT_GOOD_EXPKEY;
          	  break;
          
          	default:
          	  *r_stat = GPGME_SIG_STAT_ERROR;
          	  break;
          	}
              }
            if (r_created)
              *r_created = sig-&gt;timestamp;
            return sig-&gt;fpr;
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Function: const char * <b>gpgme_get_sig_string_attr</b> (<var>gpgme_ctx_t&nbsp;ctx<!-- /@w -->, int&nbsp;idx<!-- /@w -->, gpgme_attr_t&nbsp;what<!-- /@w -->, int&nbsp;whatidx<!-- /@w --></var>)<var><a name="index-gpgme_005fget_005fsig_005fstring_005fattr-276"></a></var><br>
<blockquote><p>The function <code>gpgme_get_sig_string_attr</code> is equivalent to:

     <pre class="example">            gpgme_verify_result_t result;
            gpgme_signature_t sig;
          
            result = gpgme_op_verify_result (ctx);
            sig = result-&gt;signatures;
          
            while (sig &amp;&amp; idx)
              {
                sig = sig-&gt;next;
                idx--;
              }
            if (!sig || idx)
              return NULL;
          
            switch (what)
              {
              case GPGME_ATTR_FPR:
                return sig-&gt;fpr;
          
              case GPGME_ATTR_ERRTOK:
                if (whatidx == 1)
                  return sig-&gt;wrong_key_usage ? "Wrong_Key_Usage" : "";
                else
          	return "";
              default:
                break;
              }
          
            return NULL;
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Function: const char * <b>gpgme_get_sig_ulong_attr</b> (<var>gpgme_ctx_t&nbsp;ctx<!-- /@w -->, int&nbsp;idx<!-- /@w -->, gpgme_attr_t&nbsp;waht<!-- /@w -->, int&nbsp;whatidx<!-- /@w --></var>)<var><a name="index-gpgme_005fget_005fsig_005fulong_005fattr-277"></a></var><br>
<blockquote><p>The function <code>gpgme_get_sig_ulong_attr</code> is equivalent to:

     <pre class="example">            gpgme_verify_result_t result;
            gpgme_signature_t sig;
          
            result = gpgme_op_verify_result (ctx);
            sig = result-&gt;signatures;
          
            while (sig &amp;&amp; idx)
              {
                sig = sig-&gt;next;
                idx--;
              }
            if (!sig || idx)
              return 0;
          
            switch (what)
              {
              case GPGME_ATTR_CREATED:
                return sig-&gt;timestamp;
          
              case GPGME_ATTR_EXPIRE:
                return sig-&gt;exp_timestamp;
          
              case GPGME_ATTR_VALIDITY:
                return (unsigned long) sig-&gt;validity;
          
              case GPGME_ATTR_SIG_STATUS:
                switch (sig-&gt;status)
          	{
          	case GPG_ERR_NO_ERROR:
          	  return GPGME_SIG_STAT_GOOD;
          
          	case GPG_ERR_BAD_SIGNATURE:
          	  return GPGME_SIG_STAT_BAD;
          
          	case GPG_ERR_NO_PUBKEY:
          	  return GPGME_SIG_STAT_NOKEY;
          
          	case GPG_ERR_NO_DATA:
          	  return GPGME_SIG_STAT_NOSIG;
          
          	case GPG_ERR_SIG_EXPIRED:
          	  return GPGME_SIG_STAT_GOOD_EXP;
          
          	case GPG_ERR_KEY_EXPIRED:
          	  return GPGME_SIG_STAT_GOOD_EXPKEY;
          
          	default:
          	  return GPGME_SIG_STAT_ERROR;
          	}
          
              case GPGME_ATTR_SIG_SUMMARY:
                return sig-&gt;summary;
          
              default:
                break;
              }
            return 0;
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Function: const char * <b>gpgme_get_sig_key</b> (<var>gpgme_ctx_t&nbsp;ctx<!-- /@w -->, int&nbsp;idx<!-- /@w -->, gpgme_key_t&nbsp;*r_key<!-- /@w --></var>)<var><a name="index-gpgme_005fget_005fsig_005fkey-278"></a></var><br>
<blockquote><p>The function <code>gpgme_get_sig_key</code> is equivalent to:

     <pre class="example">            gpgme_verify_result_t result;
            gpgme_signature_t sig;
          
            result = gpgme_op_verify_result (ctx);
            sig = result-&gt;signatures;
          
            while (sig &amp;&amp; idx)
              {
                sig = sig-&gt;next;
                idx--;
              }
            if (!sig || idx)
              return gpg_error (GPG_ERR_EOF);
          
            return gpgme_get_key (ctx, sig-&gt;fpr, r_key, 0);
</pre>
        </blockquote></div>

   </body></html>

