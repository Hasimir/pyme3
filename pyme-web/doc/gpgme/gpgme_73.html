<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/html40/loose.dtd">
<HTML>
<!-- Created on June, 7 2005 by texi2html 1.66 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<HEAD>
<TITLE>The `GnuPG Made Easy' Reference Manual: I/O Callback Example</TITLE>

<META NAME="description" CONTENT="The `GnuPG Made Easy' Reference Manual: I/O Callback Example">
<META NAME="keywords" CONTENT="The `GnuPG Made Easy' Reference Manual: I/O Callback Example">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.66">

</HEAD>

<BODY LANG="en" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC73"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gpgme_72.html#SEC72"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gpgme_74.html#SEC74"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gpgme_34.html#SEC34"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gpgme_70.html#SEC70"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gpgme_78.html#SEC78"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gpgme.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gpgme_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gpgme_81.html#SEC81">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gpgme_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<HR SIZE=1>
<H4> 7.7.2.3 I/O Callback Example </H4>
<!--docid::SEC73::-->
<P>

To actually use an external event loop, you have to implement the I/O
callback functions that are used by <FONT SIZE="-1">GPGME</FONT> to register and
unregister file descriptors.  Furthermore, you have to actually
monitor these file descriptors for activity and call the appropriate
I/O callbacks.
</P>
<P>

The following example illustrates how to do that.  The example uses
locking to show in which way the the callbacks and the event loop can
run concurrently.  For the event loop, we use a fixed array.  For a
real-world implementation, you should use a dynamically sized
structure because the number of file descriptors needed for a crypto
operation in <FONT SIZE="-1">GPGME</FONT> is not predictable.
</P>
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>#include &lt;pthread.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;gpgme.h&gt;

/* The following structure holds the result of a crypto operation.  */
struct op_result
{
  int done;
  gpgme_error_t err;
};

/* The following structure holds the data associated with one I/O
callback.  */
struct one_fd
{
  int fd;
  int dir;
  gpgme_io_cb_t fnc;
  void *fnc_data;
};

struct event_loop
{
  pthread_mutex_t lock;
#define MAX_FDS 32
  /* Unused slots are marked with FD being -1.  */
  struct one_fd fds[MAX_FDS];
};
</pre></td></tr></table><P>

The following functions implement the I/O callback interface.
</P>
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>gpgme_error_t
add_io_cb (void *data, int fd, int dir, gpgme_io_cb_t fnc, void *fnc_data,
	   void **r_tag)
{
  struct event_loop *loop = data;
  struct one_fd *fds = loop-&gt;fds;
  int i;

  pthread_mutex_lock (&amp;loop-&gt;lock);
  for (i = 0; i &lt; MAX_FDS; i++)
    {
      if (fds[i].fd == -1)
	{
	  fds[i].fd = fd;
	  fds[i].dir = dir;
	  fds[i].fnc = fnc;
	  fds[i].fnc_data = fnc_data;
	  break;
	}
    }
  pthread_mutex_unlock (&amp;loop-&gt;lock);
  if (i == MAX_FDS)
    return gpg_error (GPG_ERR_GENERAL);
  *r_tag = &amp;fds[i];
  return 0;
}

void
remove_io_cb (void *tag)
{
  struct one_fd *fd = tag;

  pthread_mutex_lock (&amp;loop-&gt;lock);
  fd-&gt;fd = -1;
  pthread_mutex_unlock (&amp;loop-&gt;lock);
}

void
event_io_cb (void *data, gpgme_event_io_t type, void *type_data)
{
  struct op_result *result = data;

  /* We don't support list operations here.  */
  if (type == GPGME_EVENT_DONE)
    {
      result-&gt;done = 1;
      result-&gt;err = *type_data;
    }
}
</pre></td></tr></table><P>

The final missing piece is the event loop, which will be presented
next.  We only support waiting for the success of a single operation.
</P>
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>int
do_select (struct event_loop *loop)
{
  fd_set rfds;
  fd_set wfds;
  int i, n;
  int any = 0;

  pthread_mutex_lock (&amp;loop-&gt;lock);
  FD_ZERO (&amp;rfds);
  FD_ZERO (&amp;wfds);
  for (i = 0; i &lt; FDLIST_MAX; i++)
    if (fdlist[i].fd != -1)
      FD_SET (fdlist[i].fd, fdlist[i].dir ? &amp;rfds : &amp;wfds);
  pthread_mutex_unlock (&amp;loop-&gt;unlock);

  do
    {
      n = select (FD_SETSIZE, &amp;rfds, &amp;wfds, NULL, 0);
    }
  while (n &lt; 0 &amp;&amp; errno == EINTR);

  if (n &lt; 0)
    return n;	/* Error or timeout.  */

  pthread_mutex_lock (&amp;loop-&gt;lock);
  for (i = 0; i &lt; FDLIST_MAX &amp;&amp; n; i++)
    {
      if (fdlist[i].fd != -1)
	{
	  if (FD_ISSET (fdlist[i].fd, fdlist[i].dir ? &amp;rfds : &amp;wfds))
	    {
	      assert (n);
	      n--;
	      any = 1;
              /* The I/O callback handler can register/remove callbacks,
                 so we have to unlock the file descriptor list.  */
              pthread_mutex_unlock (&amp;loop-&gt;lock);
	      (*fdlist[i].fnc) (fdlist[i].fnc_data, fdlist[i].fd);
              pthread_mutex_lock (&amp;loop-&gt;lock);
	    }
	}
    }
  pthread_mutex_unlock (&amp;loop-&gt;lock);
  return any;
}

void
wait_for_op (struct event_loop *loop, struct op_result *result)
{
  int ret;

  do
    {
      ret = do_select (loop);
    }
  while (ret &gt;= 0 &amp;&amp; !result-&gt;done);
  return ret;
}
</pre></td></tr></table><P>

The main function shows how to put it all together.
</P>
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>int
main (int argc, char *argv[])
{
  struct event_loop loop;
  struct op_result result;
  gpgme_ctx_t ctx;
  gpgme_error_t err;
  gpgme_data_t sig, text;
  gpgme_sig_stat_t status;
  int i;
  struct gpgme_io_cb_ts io_cbs =
  {
    add_io_cb,
    &amp;loop,
    remove_io_cb,
    event_io_cb,
    &amp;result
  };

  /* Initialize the loop structure.  */
  loop.lock = PTHREAD_MUTEX_INITIALIZER;
  for (i = 0; i &lt; MAX_FDS; i++)
    loop-&gt;fds[i].fd = -1;

  /* Initialize the result structure.  */
  result.done = 0;

  err = gpgme_data_new_from_file (&amp;sig, &quot;signature&quot;, 1);
  if (!err)
    err = gpgme_data_new_from_file (&amp;text, &quot;text&quot;, 1);
  if (!err)
    err = gpgme_new (&amp;ctx);
  if (!err)
    {
       gpgme_set_io_cbs (ctx, &amp;io_cbs);
       err = gpgme_op_verify_start (ctx, sig, text, &amp;status);
    }
  if (err)
    {
      fprintf (stderr, &quot;gpgme error: %s: %s\n&quot;,
               gpgme_strsource (err), gpgme_strerror (err));
      exit (1);
    }

  wait_for_op (&amp;loop, &amp;result);
  if (!result.done)
    {
      fprintf (stderr, &quot;select error\n&quot;);
      exit (1);
    }
  if (!result.err)
    {
      fprintf (stderr, &quot;verification failed: %s: %s\n&quot;,
               gpgme_strsource (result.err), gpgme_strerror (result.err));
      exit (1);
    }
  /* Evaluate STATUS.  */
  <small>...</small>
  return 0;
}
</pre></td></tr></table><P>

<A NAME="I/O Callback Example GTK+"></A>
<HR SIZE=1>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gpgme_72.html#SEC72"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gpgme_74.html#SEC74"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gpgme_34.html#SEC34"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gpgme_70.html#SEC70"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gpgme_78.html#SEC78"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gpgme.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gpgme_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gpgme_81.html#SEC81">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gpgme_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<BR>
<FONT SIZE="-1">
This document was generated
by <I>Igor Belyi</I> on <I>June, 7 2005</I>
using <A HREF="http://texi2html.cvshome.org"><I>texi2html</I></A>
</FONT>

</BODY>
</HTML>
