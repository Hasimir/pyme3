<html lang="en">
<head>
<title>I/O Callback Example - The `GnuPG Made Easy' Reference Manual</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="The `GnuPG Made Easy' Reference Manual">
<meta name="generator" content="makeinfo 4.11">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Using-External-Event-Loops.html#Using-External-Event-Loops" title="Using External Event Loops">
<link rel="prev" href="Registering-I_002fO-Callbacks.html#Registering-I_002fO-Callbacks" title="Registering I/O Callbacks">
<link rel="next" href="I_002fO-Callback-Example-GTK_002b.html#I_002fO-Callback-Example-GTK_002b" title="I/O Callback Example GTK+">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<p>
<a name="I%2fO-Callback-Example"></a>
<a name="I_002fO-Callback-Example"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="I_002fO-Callback-Example-GTK_002b.html#I_002fO-Callback-Example-GTK_002b">I/O Callback Example GTK+</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Registering-I_002fO-Callbacks.html#Registering-I_002fO-Callbacks">Registering I/O Callbacks</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Using-External-Event-Loops.html#Using-External-Event-Loops">Using External Event Loops</a>
<hr>
</div>

<h5 class="subsubsection">7.7.2.3 I/O Callback Example</h5>

<p>To actually use an external event loop, you have to implement the I/O
callback functions that are used by <acronym>GPGME</acronym> to register and
unregister file descriptors.  Furthermore, you have to actually
monitor these file descriptors for activity and call the appropriate
I/O callbacks.

   <p>The following example illustrates how to do that.  The example uses
locking to show in which way the callbacks and the event loop can
run concurrently.  For the event loop, we use a fixed array.  For a
real-world implementation, you should use a dynamically sized
structure because the number of file descriptors needed for a crypto
operation in <acronym>GPGME</acronym> is not predictable.

<pre class="example">     #include &lt;pthread.h&gt;
     #include &lt;sys/types.h&gt;
     #include &lt;gpgme.h&gt;
     
     /* The following structure holds the result of a crypto operation.  */
     struct op_result
     {
       int done;
       gpgme_error_t err;
     };
     
     /* The following structure holds the data associated with one I/O
     callback.  */
     struct one_fd
     {
       int fd;
       int dir;
       gpgme_io_cb_t fnc;
       void *fnc_data;
     };
     
     struct event_loop
     {
       pthread_mutex_t lock;
     #define MAX_FDS 32
       /* Unused slots are marked with FD being -1.  */
       struct one_fd fds[MAX_FDS];
     };
</pre>
   <p>The following functions implement the I/O callback interface.

<pre class="example">     gpgme_error_t
     add_io_cb (void *data, int fd, int dir, gpgme_io_cb_t fnc, void *fnc_data,
     	   void **r_tag)
     {
       struct event_loop *loop = data;
       struct one_fd *fds = loop-&gt;fds;
       int i;
     
       pthread_mutex_lock (&amp;loop-&gt;lock);
       for (i = 0; i &lt; MAX_FDS; i++)
         {
           if (fds[i].fd == -1)
     	{
     	  fds[i].fd = fd;
     	  fds[i].dir = dir;
     	  fds[i].fnc = fnc;
     	  fds[i].fnc_data = fnc_data;
     	  break;
     	}
         }
       pthread_mutex_unlock (&amp;loop-&gt;lock);
       if (i == MAX_FDS)
         return gpg_error (GPG_ERR_GENERAL);
       *r_tag = &amp;fds[i];
       return 0;
     }
     
     void
     remove_io_cb (void *tag)
     {
       struct one_fd *fd = tag;
     
       pthread_mutex_lock (&amp;loop-&gt;lock);
       fd-&gt;fd = -1;
       pthread_mutex_unlock (&amp;loop-&gt;lock);
     }
     
     void
     event_io_cb (void *data, gpgme_event_io_t type, void *type_data)
     {
       struct op_result *result = data;
     
       /* We don't support list operations here.  */
       if (type == GPGME_EVENT_DONE)
         {
           result-&gt;done = 1;
           result-&gt;err = *type_data;
         }
     }
</pre>
   <p>The final missing piece is the event loop, which will be presented
next.  We only support waiting for the success of a single operation.

<pre class="example">     int
     do_select (struct event_loop *loop)
     {
       fd_set rfds;
       fd_set wfds;
       int i, n;
       int any = 0;
     
       pthread_mutex_lock (&amp;loop-&gt;lock);
       FD_ZERO (&amp;rfds);
       FD_ZERO (&amp;wfds);
       for (i = 0; i &lt; FDLIST_MAX; i++)
         if (fdlist[i].fd != -1)
           FD_SET (fdlist[i].fd, fdlist[i].dir ? &amp;rfds : &amp;wfds);
       pthread_mutex_unlock (&amp;loop-&gt;unlock);
     
       do
         {
           n = select (FD_SETSIZE, &amp;rfds, &amp;wfds, NULL, 0);
         }
       while (n &lt; 0 &amp;&amp; errno == EINTR);
     
       if (n &lt; 0)
         return n;	/* Error or timeout.  */
     
       pthread_mutex_lock (&amp;loop-&gt;lock);
       for (i = 0; i &lt; FDLIST_MAX &amp;&amp; n; i++)
         {
           if (fdlist[i].fd != -1)
     	{
     	  if (FD_ISSET (fdlist[i].fd, fdlist[i].dir ? &amp;rfds : &amp;wfds))
     	    {
     	      assert (n);
     	      n--;
     	      any = 1;
                   /* The I/O callback handler can register/remove callbacks,
                      so we have to unlock the file descriptor list.  */
                   pthread_mutex_unlock (&amp;loop-&gt;lock);
     	      (*fdlist[i].fnc) (fdlist[i].fnc_data, fdlist[i].fd);
                   pthread_mutex_lock (&amp;loop-&gt;lock);
     	    }
     	}
         }
       pthread_mutex_unlock (&amp;loop-&gt;lock);
       return any;
     }
     
     void
     wait_for_op (struct event_loop *loop, struct op_result *result)
     {
       int ret;
     
       do
         {
           ret = do_select (loop);
         }
       while (ret &gt;= 0 &amp;&amp; !result-&gt;done);
       return ret;
     }
</pre>
   <p>The main function shows how to put it all together.

<pre class="example">     int
     main (int argc, char *argv[])
     {
       struct event_loop loop;
       struct op_result result;
       gpgme_ctx_t ctx;
       gpgme_error_t err;
       gpgme_data_t sig, text;
       gpgme_sig_stat_t status;
       int i;
       struct gpgme_io_cb_ts io_cbs =
       {
         add_io_cb,
         &amp;loop,
         remove_io_cb,
         event_io_cb,
         &amp;result
       };
     
       /* Initialize the loop structure.  */
       loop.lock = PTHREAD_MUTEX_INITIALIZER;
       for (i = 0; i &lt; MAX_FDS; i++)
         loop-&gt;fds[i].fd = -1;
     
       /* Initialize the result structure.  */
       result.done = 0;
     
       err = gpgme_data_new_from_file (&amp;sig, "signature", 1);
       if (!err)
         err = gpgme_data_new_from_file (&amp;text, "text", 1);
       if (!err)
         err = gpgme_new (&amp;ctx);
       if (!err)
         {
            gpgme_set_io_cbs (ctx, &amp;io_cbs);
            err = gpgme_op_verify_start (ctx, sig, text, &amp;status);
         }
       if (err)
         {
           fprintf (stderr, "gpgme error: %s: %s\n",
                    gpgme_strsource (err), gpgme_strerror (err));
           exit (1);
         }
     
       wait_for_op (&amp;loop, &amp;result);
       if (!result.done)
         {
           fprintf (stderr, "select error\n");
           exit (1);
         }
       if (!result.err)
         {
           fprintf (stderr, "verification failed: %s: %s\n",
                    gpgme_strsource (result.err), gpgme_strerror (result.err));
           exit (1);
         }
       /* Evaluate STATUS.  */
       ...
       return 0;
     }
</pre>
   </body></html>

