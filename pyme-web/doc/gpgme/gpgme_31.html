<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/html40/loose.dtd">
<HTML>
<!-- Created on June, 7 2005 by texi2html 1.66 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<HEAD>
<TITLE>The `GnuPG Made Easy' Reference Manual: Callback Based Data Buffers</TITLE>

<META NAME="description" CONTENT="The `GnuPG Made Easy' Reference Manual: Callback Based Data Buffers">
<META NAME="keywords" CONTENT="The `GnuPG Made Easy' Reference Manual: Callback Based Data Buffers">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.66">

</HEAD>

<BODY LANG="en" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC31"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gpgme_30.html#SEC30"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gpgme_32.html#SEC32"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gpgme_27.html#SEC27"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gpgme_28.html#SEC28"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gpgme_34.html#SEC34"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gpgme.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gpgme_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gpgme_81.html#SEC81">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gpgme_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<HR SIZE=1>
<H3> 6.1.3 Callback Based Data Buffers </H3>
<!--docid::SEC31::-->
<P>

If neither memory nor file based data objects are a good fit for your
application, you can implement the functions a data object provides
yourself and create a data object from these callback functions.
</P>
<P>

<A NAME="IDX39"></A>
</P>
<DL>
<DT><U>Data type:</U> <B>ssize_t (*gpgme_data_read_cb_t) (void *<VAR>handle</VAR>, void <VAR>*buffer</VAR>, size_t <VAR>size</VAR>)</B>
<DD><A NAME="IDX40"></A>
The <CODE>gpgme_data_read_cb_t</CODE> type is the type of functions which
<FONT SIZE="-1">GPGME</FONT> calls if it wants to read data from a user-implemented
data object.  The function should read up to <VAR>size</VAR> bytes from the
current read position into the space starting at <VAR>buffer</VAR>.  The
<VAR>handle</VAR> is provided by the user at data object creation time.
<P>

The function should return the number of bytes read, 0 on EOF, and -1
on error.  If an error occurs, <VAR>errno</VAR> should be set to describe
the type of the error.
</P>
</DL>
<P>

<A NAME="IDX41"></A>
</P>
<DL>
<DT><U>Data type:</U> <B>ssize_t (*gpgme_data_write_cb_t) (void *<VAR>handle</VAR>, const void <VAR>*buffer</VAR>, size_t <VAR>size</VAR>)</B>
<DD><A NAME="IDX42"></A>
The <CODE>gpgme_data_write_cb_t</CODE> type is the type of functions which
<FONT SIZE="-1">GPGME</FONT> calls if it wants to write data to a user-implemented
data object.  The function should write up to <VAR>size</VAR> bytes to the
current write position from the space starting at <VAR>buffer</VAR>.  The
<VAR>handle</VAR> is provided by the user at data object creation time.
<P>

The function should return the number of bytes written, and -1 on
error.  If an error occurs, <VAR>errno</VAR> should be set to describe the
type of the error.
</P>
</DL>
<P>

<A NAME="IDX43"></A>
</P>
<DL>
<DT><U>Data type:</U> <B>off_t (*gpgme_data_seek_cb_t) (void *<VAR>handle</VAR>, off_t <VAR>offset</VAR>, int <VAR>whence</VAR>)</B>
<DD><A NAME="IDX44"></A>
The <CODE>gpgme_data_seek_cb_t</CODE> type is the type of functions which
<FONT SIZE="-1">GPGME</FONT> calls if it wants to change the current read/write
position in a user-implemented data object, just like the <CODE>lseek</CODE>
function.
<P>

The function should return the new read/write position, and -1 on
error.  If an error occurs, <VAR>errno</VAR> should be set to describe the
type of the error.
</P>
</DL>
<P>

<A NAME="IDX45"></A>
</P>
<DL>
<DT><U>Data type:</U> <B>void (*gpgme_data_release_cb_t) (void *<VAR>handle</VAR>)</B>
<DD><A NAME="IDX46"></A>
The <CODE>gpgme_data_release_cb_t</CODE> type is the type of functions which
<FONT SIZE="-1">GPGME</FONT> calls if it wants to destroy a user-implemented data
object.  The <VAR>handle</VAR> is provided by the user at data object
creation time.
</DL>
<P>

<A NAME="IDX47"></A>
</P>
<DL>
<DT><U>Data type:</U> <B>struct gpgme_data_cbs</B>
<DD>This structure is used to store the data callback interface functions
described above.  It has the following members:
<P>

</P>
<DL COMPACT>
<DT><CODE>gpgme_data_read_cb_t read</CODE>
<DD>This is the function called by <FONT SIZE="-1">GPGME</FONT> to read data from the
data object.  It is only required for input data object.
<P>

</P>
<DT><CODE>gpgme_data_write_cb_t write</CODE>
<DD>This is the function called by <FONT SIZE="-1">GPGME</FONT> to write data to the
data object.  It is only required for output data object.
<P>

</P>
<DT><CODE>gpgme_data_seek_cb_t seek</CODE>
<DD>This is the function called by <FONT SIZE="-1">GPGME</FONT> to change the current
read/write pointer in the data object (if available).  It is optional.
<P>

</P>
<DT><CODE>gpgme_data_release_cb_t release</CODE>
<DD>This is the function called by <FONT SIZE="-1">GPGME</FONT> to release a data
object.  It is optional.
</DL>
</DL>
<P>

<A NAME="IDX48"></A>
</P>
<DL>
<DT><U>Function:</U> gpgme_error_t <B>gpgme_data_new_from_cbs</B> <I>(gpgme_data_t *<VAR>dh</VAR>, gpgme_data_cbs_t <VAR>cbs</VAR>, void *<VAR>handle</VAR>)</I>
<DD>The function <CODE>gpgme_data_new_from_cbs</CODE> creates a new
<CODE>gpgme_data_t</CODE> object and uses the user-provided callback functions
to operate on the data object.
<P>

The handle <VAR>handle</VAR> is passed as first argument to the callback
functions.  This can be used to identify this data object.
</P>
<P>

The function returns the error code <CODE>GPG_ERR_NO_ERROR</CODE> if the
data object was successfully created, and <CODE>GPG_ERR_ENOMEM</CODE> if not
enough memory is available.
</P>
</DL>
<P>

The following interface is deprecated and only provided for backward
compatibility.  Don't use it.  It will be removed in a future version
of <FONT SIZE="-1">GPGME</FONT>.
</P>
<P>

<A NAME="IDX49"></A>
</P>
<DL>
<DT><U>Function:</U> gpgme_error_t <B>gpgme_data_new_with_read_cb</B> <I>(gpgme_data_t *<VAR>dh</VAR>, int (*<VAR>readfunc</VAR>) (void *<VAR>hook</VAR>, char *<VAR>buffer</VAR>, size_t <VAR>count</VAR>, size_t *<VAR>nread</VAR>), void *<VAR>hook_value</VAR>)</I>
<DD>The function <CODE>gpgme_data_new_with_read_cb</CODE> creates a new
<CODE>gpgme_data_t</CODE> object and uses the callback function <VAR>readfunc</VAR>
to retrieve the data on demand.  As the callback function can supply
the data in any way it wants, this is the most flexible data type
<FONT SIZE="-1">GPGME</FONT> provides.  However, it can not be used to write data.
<P>

The callback function receives <VAR>hook_value</VAR> as its first argument
whenever it is invoked.  It should return up to <VAR>count</VAR> bytes in
<VAR>buffer</VAR>, and return the number of bytes actually read in
<VAR>nread</VAR>.  It may return <CODE>0</CODE> in <VAR>nread</VAR> if no data is
currently available.  To indicate <CODE>EOF</CODE> the function should
return with an error code of <CODE>-1</CODE> and set <VAR>nread</VAR> to
<CODE>0</CODE>.  The callback function may support to reset its internal
read pointer if it is invoked with <VAR>buffer</VAR> and <VAR>nread</VAR> being
<CODE>NULL</CODE> and <VAR>count</VAR> being <CODE>0</CODE>.
</P>
<P>

The function returns the error code <CODE>GPG_ERR_NO_ERROR</CODE> if the
data object was successfully created, <CODE>GPG_ERR_INV_VALUE</CODE> if
<VAR>dh</VAR> or <VAR>readfunc</VAR> is not a valid pointer, and
<CODE>GPG_ERR_ENOMEM</CODE> if not enough memory is available.
</P>
</DL>
<P>

<A NAME="Destroying Data Buffers"></A>
<HR SIZE=1>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gpgme_30.html#SEC30"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gpgme_32.html#SEC32"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gpgme_27.html#SEC27"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gpgme_28.html#SEC28"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gpgme_34.html#SEC34"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gpgme.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gpgme_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gpgme_81.html#SEC81">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gpgme_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<BR>
<FONT SIZE="-1">
This document was generated
by <I>Igor Belyi</I> on <I>June, 7 2005</I>
using <A HREF="http://texi2html.cvshome.org"><I>texi2html</I></A>
</FONT>

</BODY>
</HTML>
